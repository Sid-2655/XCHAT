<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>XCHAT Secure</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  margin: 0;
  background: #000;
  color: #00ff88;
  font-family: monospace;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

.container {
  width: 95%;
  max-width: 450px;
  text-align: center;
}

button {
  background: #001a0f;
  border: 1px solid #00ff88;
  color: #00ff88;
  padding: 12px;
  margin: 8px 0;
  width: 100%;
  font-size: 16px;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background: #00331f;
}

input, textarea {
  background: #000;
  border: 1px solid #00ff88;
  color: #00ff88;
  padding: 12px;
  width: 100%;
  margin: 8px 0;
  border-radius: 4px;
}

textarea {
  height: 200px;
  resize: none;
}

#chatScreen {
  display: none;
}

.flying-text {
  position: absolute;
  font-weight: bold;
  color: #00ff88;
  pointer-events: none;
  animation: flyUp 1s ease forwards;
  text-shadow: 0 0 8px #00ff88;
}

@keyframes flyUp {
  0% { opacity:1; transform:translateY(0px) scale(1); }
  50% { opacity:1; transform:translateY(-60px) scale(1.1); }
  100% { opacity:0; transform:translateY(-120px) scale(0.9); }
}
</style>
</head>

<body>

<div class="container">

<div id="homeScreen">
  <h2>üîê XCHAT SECURE</h2>
  <input id="sessionId" placeholder="Session ID">
  <input id="secret" placeholder="Shared Secret (Password)">
  <button onclick="host()">HOST</button>
  <button onclick="join()">JOIN</button>
</div>

<div id="chatScreen">
  <h2>üü¢ SECURE CHANNEL</h2>
  <textarea id="chat" readonly></textarea>
  <input id="msg" placeholder="Type encrypted message">
  <button onclick="send()">SEND</button>
  <button onclick="RUN()">RUN!</button>
</div>

</div>

<script>
let pc = new RTCPeerConnection({
  iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
});

let channel;
let key;
let connected = false;

pc.ondatachannel = (event) => {
  channel = event.channel;
  setupChannel();
};

pc.onconnectionstatechange = () => {
  if (pc.connectionState === "connected") {
    connected = true;
    document.getElementById("homeScreen").style.display = "none";
    document.getElementById("chatScreen").style.display = "block";
  }
};

async function deriveKey(pass) {
  const enc = new TextEncoder();
  const base = await crypto.subtle.importKey("raw", enc.encode(pass), {name:"PBKDF2"}, false, ["deriveKey"]);
  return crypto.subtle.deriveKey({
      name:"PBKDF2",
      salt:enc.encode("session-salt"),
      iterations:100000,
      hash:"SHA-256"
    },
    base,
    {name:"AES-GCM", length:256},
    false,
    ["encrypt","decrypt"]
  );
}

function RUN() {
  alert("RUN!");
  pc.close();
  document.body.innerHTML = "<h1 style='color:red;text-align:center;margin-top:40vh;'>SESSION TERMINATED</h1>";
}

async function encrypt(msg) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const enc = new TextEncoder().encode(msg);
  const data = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, enc);
  return JSON.stringify({d:Array.from(new Uint8Array(data)),iv:Array.from(iv)});
}

async function decrypt(payload) {
  try {
    const obj = JSON.parse(payload);
    const data = new Uint8Array(obj.d);
    const iv = new Uint8Array(obj.iv);
    const dec = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, data);
    return new TextDecoder().decode(dec);
  } catch {
    RUN();
  }
}

function append(text) {
  chat.value += text + "\n";
  chat.scrollTop = chat.scrollHeight;
}

function setupChannel() {
  channel.onmessage = async e => {
    const msg = await decrypt(e.data);
    if(msg) append("Friend: " + msg);
  };
  channel.onclose = RUN;
}

async function host() {
  key = await deriveKey(secret.value);

  channel = pc.createDataChannel("secure");
  setupChannel();

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  await fetch("/api/session", {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({
      id: sessionId.value,
      offer: offer
    })
  });

  pollForAnswer();
}

async function join() {
  key = await deriveKey(secret.value);

  const res = await fetch("/api/session?id=" + sessionId.value);
  const data = await res.json();

  if(!data.offer) return alert("Invalid session");

  await pc.setRemoteDescription(data.offer);

  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  await fetch("/api/session", {
    method:"PUT",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({
      id: sessionId.value,
      answer: answer
    })
  });
}

async function pollForAnswer() {
  const res = await fetch("/api/session?id=" + sessionId.value);
  const data = await res.json();
  if(data.answer) {
    await pc.setRemoteDescription(data.answer);
  } else {
    setTimeout(pollForAnswer, 1000);
  }
}

function randomChar() {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&";
  return chars[Math.floor(Math.random() * chars.length)];
}

async function send() {
  if(!connected) return RUN();
  if(!msg.value) return;

  const text = msg.value;

  const rect = msg.getBoundingClientRect();
  const flying = document.createElement("div");
  flying.className = "flying-text";
  flying.style.left = rect.left + "px";
  flying.style.top = rect.top + "px";
  document.body.appendChild(flying);

  let progress = 0;

  const glitch = setInterval(() => {
    let encryptedDisplay = "";
    for (let i = 0; i < text.length; i++) {
      encryptedDisplay += Math.random() > progress
        ? randomChar()
        : text[i];
    }

    flying.innerText = encryptedDisplay;
    progress += 0.08;

    if (progress >= 1) {
      clearInterval(glitch);
      flying.remove();
      append("Me: " + text);
    }
  }, 50);

  const encrypted = await encrypt(text);
  channel.send(encrypted);

  msg.value="";
}
</script>

</body>
</html>